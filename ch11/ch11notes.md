

BLAB:服务器连接网络四部曲
在使用套接字与客户端程序通信前,服务器需要经历4个阶段:
B:bind,绑定端口
L:listen,监听
A:accept,接收连接
B:begin,开始通信

服务器程序启动时,需要告诉os将要使用哪个端口,这个过程叫端口绑定.


套接字不是传统意义上的数据流,套接字是双向的,既可以输入也可以输出,也就是说要用其他函数和它通信.
如果想向套接字输出数据,用send而不是fprintf

当服务器已经响应某个客户端时关闭服务器,然后立即重启,bind系统调用会失败.

绑定端口有延时:
当在某个端口绑定了套接字,在接下来的30秒内,os不允许任何程序再绑定它,包括上一次绑定这个端口的程序.只要在绑定前设置套接字的某个选项就可以解决这个问题.
int reuse = 1;
if (setsocketopt(listener_d, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(int)) == -1) {
	error("无法设置套接字的"重新使用端口"选项");
}

从客户端读取数据:套接字用recv读取数据
如果用户在客户端输入一行文本,然后按下回车键,热潮v会把文本呢保存在这样一个字符数组中:
who's there?\r\n
因此,
1 字符串不以\0结尾,以\r\n结尾
2 recv将返回字符个数,如果发生错误就返回-1,如果客户端关闭了连接,就返回0
3 recv不一定能一次接收所有字符
recv用起来十分繁琐,最好把它封装在某个函数中:
```cpp
int read_in(int socket, char* buf, int len)
{
	char* s = buf;
	int slen = len;
	int c = recv(socket, s, slen, 0);
	while ((c > 0) && (s[c-1] != '\n')) {
		s += c;  slen -= c;
		c = recv(socket, s, slen, 0);
	}
	if (c < 0)
		return c;
	else if (c == 0)
		buf[0] = '\0';
	else
		s[c-1]='\0'; //用'\0'替换\r
	return len - slen;
}
```

服务器的父进程只需要用主监听套接字(用来接受新的连接),而子进程只需要处理accept创建的副套接字.
也就是说,父进程克隆出子进程后可以关闭副套接字,子进程可以关闭主监听套接字

子进程在处理完一个客户端后可以发出信号,利用这点可以用有限的子进程处理无限的客户端




