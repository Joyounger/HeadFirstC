
使用指针的主要原因之一就是让函数共享存储器.一个函数可以修改另一个函数创建的数据,只要它知道数据在存储器中的位置.


不一定要用%p格式来打印指针,在大多数现代计算机上可以用%li.但编译器可能会给出一条警告.

C编译器通常会把long数据类型设为和存储器地址一样长

如果对数组变量使用&,结果是数组本身.
数组变量不能指向其他地方:创建数组时,计算机不会为数组变量分配空间,编译器仅在出现它的地方把它替换成数组的其实地址.
如果把数组赋给指针变量,指针变量对数组长度一无所知,相当于丢失了一些信息.称为退化
指针不能相乘

scanf表示scan formatted
为什么scanf要接收指针:因为scanf打算更新变量内容,一个想要更新变量的函数可不需要变量本身的值,它要的是变量的地址.

scanf会导致缓冲区溢出:如果忘了限制scanf读取字符串的长度,用户就可输入远超程序空间的数据,多余的数据会写到计算机还没有分配好的存储器中.如果运气好,数据不但能保存,而且不会有任何问题.但缓冲区溢出有可能导致程序出错,这种情况称为段错误或abort trap,程序会崩溃.

fgets相对于scanf必须指定最大长度.fgets()缓冲区把\0字符也算了进去,不必像scanf那样把长度减1
fgets比scanf更安全,但它的祖先gets()是最不安全的,gets()没有任何限制,不应该用


限制:scanf要记得在格式串中加入长度,fgets强制输入字符串长度
多字段:scanf不但允许输入多个字段,而且允许输入结构化数据,可以指定两个字段间以什么字符分隔
fges只允许向缓冲区输入一个字符串,而且只能是字符串,不能是其他数据类型,只能有一个缓冲区.
字符串中的空格:scanf用%s读取字符串时,遇到空格就会停止.如果想输入多个单词,需要多次调用scanf,或使用正则表达式技巧.fgets无论何时都能读取整个字符串.
如果需要输入由多个字符按构成的结构化数据,可以使用scanf;而如果想要输入一个非结构化的字符串,fgets将是你的不二之选.

如果想把指针设为字符串字面值,必须确保使用了const关键字,这样编译时如果发现试图修改字符串,就会提示编译错误.
```cpp
int main()
{
        const char *s = "some string";
        s[0] = 'S';
        return 0;
}
$ gcc temp.c -o temp
temp.c: In function ‘main’:
temp.c:5:7: error: assignment of read-only location ‘*s’
  s[0] = 'S';
       ^
```



